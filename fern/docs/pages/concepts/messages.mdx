---
title: Messages
subtitle: Understanding message handling in the AUI API
slug: messages
---

Messages are the building blocks of conversations in the AUI API. Each message represents a single communication from either a user or an AI agent within a task.

## Message Structure

Every message includes:

- **Message ID** - Unique identifier for the message
- **Task ID** - The task this message belongs to
- **Content** - The text content of the message
- **Actor** - Who sent the message (user or agent)
- **Timestamp** - When the message was created

## Submitting Messages

Submit a message to a task using the REST API:

```bash
POST /tasks/{task_id}/messages
```

**Request Body:**

```json
{
  "content": "I need help with my order",
  "actor": "user"
}
```

**Response:**

```json
{
  "message_id": "msg_101",
  "task_id": "task_789",
  "content": "I need help with my order",
  "actor": "user",
  "timestamp": "2025-11-05T23:01:00Z"
}
```

## Actor Types

Messages can come from two types of actors:

### User Messages

Messages from end users:

```json
{
  "content": "What is the status of my order?",
  "actor": "user"
}
```

### Agent Messages

Messages from the AI agent (Apollo-1):

```json
{
  "content": "Your order is currently being processed and will ship tomorrow.",
  "actor": "agent"
}
```

## Retrieving Messages

Get all messages for a task:

```bash
GET /tasks/{task_id}/messages
```

**Query Parameters:**

- `page` - Page number (default: 1)
- `page_size` - Number of messages per page (default: 50, max: 100)

**Response:**

```json
{
  "messages": [
    {
      "message_id": "msg_101",
      "content": "I need help with my order",
      "actor": "user",
      "timestamp": "2025-11-05T23:01:00Z"
    },
    {
      "message_id": "msg_102",
      "content": "I'd be happy to help. What's your order number?",
      "actor": "agent",
      "timestamp": "2025-11-05T23:01:05Z"
    }
  ],
  "pagination": {
    "total": 2,
    "page": 1,
    "page_size": 50,
    "has_more": false
  }
}
```

## Message Ordering

Messages are returned in chronological order (oldest first). This ensures conversations flow naturally from start to finish.

## Pagination

For tasks with many messages, use pagination:

```typescript
// Get all messages for a task
const messages = await client.controllerApi.getTaskMessages(taskId);

console.log(`Total messages: ${messages.length}`);
messages.forEach(msg => {
  console.log(`[${msg.sender.type}]: ${msg.text}`);
});
```

## Best Practices

### Message Content

Keep message content clear and concise:

- Use natural language
- Provide sufficient context
- Avoid overly long messages

### Error Handling

Handle message submission errors:

```typescript
try {
  const messageResponse = await client.controllerApi.sendMessage({
    task_id: taskId,
    text: userInput,
    is_external_api: true
  });
  
  console.log('Agent response:', messageResponse.text);
} catch (error) {
  if (error.statusCode === 404) {
    console.error('Task not found');
  } else {
    console.error('Failed to submit message:', error);
  }
}
```

### Rate Limiting

Be mindful of rate limits when submitting messages in rapid succession. Implement appropriate throttling in your application.

## Real-time Updates

For real-time message delivery, use the [WebSocket API](/websocket) instead of polling the REST API.

## Next Steps

- Learn about [WebSocket Communication](/websocket) for real-time messaging
- Explore [Tasks](/tasks) to understand task management
- Check the [API Reference](/api-reference) for complete endpoint documentation
