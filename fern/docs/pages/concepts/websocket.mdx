---
title: WebSocket Communication
subtitle: Real-time bidirectional communication with Apollo-1
slug: websocket
---

The AUI WebSocket API enables real-time bidirectional communication between your application and Apollo-1. This allows for streaming responses, instant updates, and interactive conversational experiences.

## Connection

Connect to the WebSocket API using the SDK (recommended):

<CodeBlocks>
  <CodeBlock title="TypeScript">
    ```typescript
    import { ApolloClient } from '@aui.io/aui-client';

    const client = new ApolloClient({
      networkApiKey: 'YOUR_API_KEY'
    });

    const socket = await client.apolloWsSession.connect();
    // SDK handles authentication via x-network-api-key header automatically
    ```
  </CodeBlock>
  <CodeBlock title="Python">
    ```python
    from aui import ApolloClient
    from aui.apollo_ws_session.client import ApolloWsSessionClient

    client = ApolloClient(network_api_key='YOUR_API_KEY')
    apollo_ws = ApolloWsSessionClient(client_wrapper=client._client_wrapper)

    with apollo_ws.connect() as socket:
        # SDK handles authentication via x-network-api-key header automatically
        pass
    ```
  </CodeBlock>
</CodeBlocks>

**Connection Details:**
- **URL**: `wss://api.aui.io/ia-controller/api/v1/external/session`
- **Authentication**: Via `x-network-api-key` header (handled automatically by SDK)
- **Protocol**: WebSocket (wss)

<Note>
The SDK uses the default production environment. The `x-network-api-key` header is added automatically when you initialize the client with your API key.
</Note>

## Message Types

The WebSocket API has three main message types:

### 1. Streaming Updates (Partial Text)

Real-time text chunks as the agent generates the response:

```json
{
  "channel": {
    "event_name": "thread-message-text-content-updated"
  },
  "data": {
    "text": "The Frigidaire"
  }
}
```

### 2. Final Message (Complete Response)

Complete agent response with optional product cards and suggestions:

```json
{
  "id": "msg_123",
  "text": "The Frigidaire Gallery Series GMBS3068BF built-in microwave...",
  "sender": {
    "type": "agent",
    "id": "intelligent-agent"
  },
  "receiver": {
    "type": "user",
    "id": "user_id"
  },
  "cards": [
    {
      "id": "prod_123",
      "name": "Frigidaire Gallery Series GMBS3068BF",
      "is_recommended": true,
      "parameters": [...]
    }
  ],
  "followup_suggestions": [
    "Does it have sensor cooking?",
    "What are the dimensions?"
  ],
  "created_at": "2025-11-12T14:03:46.984000"
}
```

### 3. Error Messages

Errors sent before connection closure:

```json
{
  "status_code": 401,
  "description": "Authentication failed",
  "message": "Invalid API key"
}
```

## Using the SDK (Recommended)

The SDK handles all WebSocket complexity including authentication, reconnection, and message parsing:

<CodeBlocks>
  <CodeBlock title="TypeScript">
    ```typescript
    import { ApolloClient } from '@aui.io/aui-client';

    const client = new ApolloClient({
      networkApiKey: 'YOUR_API_KEY'
    });

    const socket = await client.apolloWsSession.connect({
      reconnectAttempts: 30,
      debug: false
    });

    // Send message
    socket.on('open', () => {
      socket.sendUserMessage({
        task_id: 'your_task_id',
        text: 'Show me gaming laptops under $1500'
      });
    });

    // Handle messages
    socket.on('message', (message) => {
      // Streaming updates
      if (message.channel?.eventName === 'thread-message-text-content-updated') {
        console.log('Agent typing:', message.data?.text);
      }
      
      // Final message
      if (message.id && message.text) {
        console.log('Complete response:', message.text);
        
        if (message.cards) {
          message.cards.forEach(card => {
            console.log(`Product: ${card.name}`);
          });
        }
      }
    });
    ```
  </CodeBlock>
  <CodeBlock title="Python">
    ```python
    from aui import ApolloClient
    from aui.apollo_ws_session.client import ApolloWsSessionClient
    from aui.types.user_message_payload import UserMessagePayload

    client = ApolloClient(network_api_key='YOUR_API_KEY')
    apollo_ws = ApolloWsSessionClient(client_wrapper=client._client_wrapper)

    with apollo_ws.connect() as socket:
        # Send message
        message_payload = UserMessagePayload(
            task_id='your_task_id',
            text='Show me gaming laptops under $1500'
        )
        socket.send_user_message(message_payload)
        
        # Receive messages
        for message in socket:
            # Streaming
            if hasattr(message, 'channel') and message.channel:
                print(f'Agent typing: {message.data.text}')
            
            # Final message
            elif hasattr(message, 'id') and hasattr(message, 'text'):
                print(f'Complete: {message.text}')
                
                if hasattr(message, 'cards') and message.cards:
                    for card in message.cards:
                        print(f'Product: {card.name}')
                
                break
    ```
  </CodeBlock>
</CodeBlocks>

## Close Codes

The WebSocket API uses specific close codes:

| Code | Meaning | Action |
|------|---------|--------|
| 1000 | Normal closure | No action needed |
| 1008 | Policy violation | Check authentication |
| 4001 | Invalid authentication | Verify API key |
| 4002 | Task not found | Verify task ID |
| 4003 | Rate limit exceeded | Implement backoff |

## Authentication

**Important**: WebSocket authentication is handled via the `x-network-api-key` **HEADER**, not query parameters.

When using the SDK, authentication is handled automatically. The SDK adds the `x-network-api-key` header when establishing the connection.

## Best Practices

### Use the Official SDK

The SDK provides:
- ✅ Automatic header-based authentication
- ✅ Built-in reconnection logic
- ✅ Proper message parsing
- ✅ Type safety (TypeScript/Python types)
- ✅ Event-driven architecture

### Handle All Message Types

Make sure to handle streaming updates, final messages, and errors:

<CodeBlocks>
  <CodeBlock title="TypeScript">
    ```typescript
    socket.on('message', (message) => {
      if (message.channel?.eventName === 'thread-message-text-content-updated') {
        // Streaming update
      } else if (message.id && message.text) {
        // Final message
      } else if (message.statusCode) {
        // Error
      }
    });
    ```
  </CodeBlock>
  <CodeBlock title="Python">
    ```python
    for message in socket:
        if hasattr(message, 'channel') and message.channel:
            # Streaming update
            pass
        elif hasattr(message, 'id') and hasattr(message, 'text'):
            # Final message
            break
        elif hasattr(message, 'status_code'):
            # Error
            break
    ```
  </CodeBlock>
</CodeBlocks>

### Connection Management

- The SDK automatically handles reconnections (up to 30 attempts by default)
- Always close the connection when done
- Handle errors gracefully

## Next Steps

- Learn about [Tasks](/tasks) and [Messages](/messages)
- Follow the [Real-time Communication Tutorial](/realtime-communication)
- Check the [API Reference](/api-reference) for complete documentation
